#!/usr/bin/env -S bash -i
# if STASH is an environment variable it will override local definition of stash
# (the place where we look for secrets)
STASH=${STASH-~/.secrets}
RZ="\e[0m"
GR="\e[92m"
RD="\e[91m"
HL="\e[1m"

function die { EN=$1; shift; echo -e ERR:${RD}$@${RZ}; exit $EN; }

mkdir $STASH &> /dev/null
chmod 700 $STASH
if [ ! -z "$1" ]; then
    if [ -f "$1" ]; then
        FILE="$1";
    elif [ -f "$STASH/$1" ]; then
        FILE="$STASH/$1";
    else
         die 1 no secret found for $1 check ls $STASH
    fi
else
    i=1;
    for f in $( ls -rt $STASH/* 2>/dev/null || echo '' ) ; do
        if [ ! -z "$f" ]; then
            STATUS=$( [[ $( stat --printf "%a" $f )  == "600" ]] \
                || echo -n "${RD}pliz chmod 600 $f" )
            ff=` basename $f `
            if [ "$ff" != '.' ] && [ "$ff" != '..' ]; then
                printf "%3d: %-32s %s " $i "$ff"  ;
                echo -e $STATUS ${RZ}
                FL[i]=$f
                i=`echo $(( i + 1 )) `
            fi
        fi
    done
    [[ "$i" == "1" ]] && die 3 "maybe you want to create a file in $STASH ?"
    echo "which secret do you want if any?"
    read choice
    FILE="${FL[$choice]}"
fi
[ -f "$FILE" ] || die 2 no such secret
CAGE=$( basename $FILE )
if [ ! -z "$CAGE_C" ]; then
    CAGE_C="${CAGE_C}->${CAGE}"
else
    CAGE_C="#SEC:${CAGE}"
fi
export CAGE
export CAGE_C
source "$FILE" || die 5 execution of ${FILE} died unexpectedly check syntax
shift

if [ -z "$1" ]; then
    PRMPT="${HL}${RD}${CAGE_C}${RZ}:"
    ( PS1="${PRMPT}$PS1" bash --norc -i)
else
    eval "$@"
fi
unset CAGE
unset CAGE_C

