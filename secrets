#!/usr/bin/env -S bash -i

STASH=${STASH-~/.secrets}
RZ='\e[0m'
GR=${GR-'\e[92m'}
RD=${RD-'\e[91m'}
HL=${HL-'\e[1m'}

function die { EN=$1; shift; echo -e "ERR::${RD}$@${RZ}"; exit "$EN"; }
function clean { unset CAGE; unset CAGE_C; unset STASH; unset RD; unset GR; unset HL; }
# don't kill me pliz
function usage { curl https://raw.githubusercontent.com/jul/secrets/main/README.md | ${PAGER-less} ; die 0 "AIDE"; }

mkdir "$STASH" &> /dev/null
chmod 700 "$STASH"
if [ ! -z "$1" ]; then
    if [ -f "$1" ]; then
        FILE="$1";
    elif [ -f "$STASH/$1" ]; then
        FILE="$STASH/$1";
    else
         die 1 "no secret found for $1 check ls $STASH"
    fi
else
    echo -e "${HL}Secrets  menu"
    echo         "-------------"
    echo
    i=1;
    echo -e "${GR}${HL}  0: aide (fetched with curl)${RZ}"
# find something saner than GNU ls here, maybe find or glob
# but I like that new files don't change the menu order ...
# it helps keeps the memory of numbers constant
# yes, I know zsh has glob with sorting.
# THE IFS TRICK !!!!
    IFS=$'\n\t';
    for f in $( ls -rfc -1 ${STASH}/* || echo '' ); do
# you won't be able to see some tricky file names BUT " " and \n are supported
# $ in the filename seems a bad idea probably a way to hide some files :)
# see samples for an example of trick not shown by the menu
        if [ ! -z "$f" ] && [ -f "$f" ]; then
            STATUS=$( [[ $( stat --printf "%a" "$f" )  == "600" ]] \
                || printf "%s" "${RD}pliz chmod 600 \"$f\"" )
            ff="$( basename "$f" )"
            if [ "$ff" != '.' ] && [ "$ff" != '..' ]; then
                printf "%3d: %-32s " $i "$ff"  ;
                echo -e "$STATUS ${RZ}"
                FL[i]=$f
                i=$(( i + 1 ))
            fi
        fi
    done
	unset IFS
    [[ "$i" == "1" ]] && die 3 "maybe you want to set a secret in $STASH ?"
    echo 
    echo "which secret do you want if any?"
    read -r choice
    [[ "$choice" == "0" ]] && usage
    FILE="${FL[$choice]}"
fi
[ -f "$FILE" ] || die 2 "no such secret"
CAGE=${CAGE-$( basename $FILE )}
source "$FILE" || \
    ( die 5 "execution of ${FILE} died unexpectedly check syntax" )
# if a ressource cleaning function is declared with the name *finally*
# in the secret execute it at exit time
declare -f finally > /dev/null && trap finally EXIT
if [ ! -z "$CAGE_C" ]; then
    CAGE_C="${CAGE_C}->${RD}${CAGE}"
else
    CAGE_C="${RD}#SEC:${CAGE}"
fi

[ -z ${HELP-""} ] || \
    ( [ -z "$USAGE" ] && echo -e "${RD}no usage found${RZ}" || die 10 "USAGE:${RZ}\\n$USAGE" )

shift
export CAGE_C
if [ -z "$1" ]; then
# sane idented use as a "python activate"
    PRMPT="${HL}${CAGE_C}${RZ}:"
    ( PS1="${PRMPT}$PS1" bash --norc -i)
else
# shell escaping hell, try to avoid
    eval "$@"
fi

